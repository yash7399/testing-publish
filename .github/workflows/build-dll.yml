name: Build each .cs → .dll

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  compile:
    runs-on: windows-latest   # Windows runner has MSBuild & .NET SDK pre-installed

    steps:
      # -------------------------------------------------
      # 1. Checkout code
      # -------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # -------------------------------------------------
      # 2. Install .NET SDK (covers .NET Framework via `msbuild`)
      # -------------------------------------------------
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x'   # any recent version works for msbuild

      # -------------------------------------------------
      # 3. Find every .cs file
      # -------------------------------------------------
      - name: List .cs files
        id: csfiles
        shell: pwsh
        run: |
          $files = Get-ChildItem -Path . -Recurse -Filter *.cs | 
                   Sort-Object FullName |
                   ForEach-Object { $_.FullName.Substring($PWD.Path.Length+1) }
          $json = $files | ConvertTo-Json -Compress
          echo "CS_FILES=$json" >> $env:GITHUB_OUTPUT
          echo "Found $($files.Count) .cs file(s)"

      # -------------------------------------------------
      # 4. Prepare output folder
      # -------------------------------------------------
      - name: Create artifacts folder
        run: mkdir artifacts

      # -------------------------------------------------
      # 5. Compile each .cs → .dll (ordered by dependency depth)
      # -------------------------------------------------
      - name: Compile .cs files
        shell: pwsh
        env:
          CS_LIST: ${{ steps.csfiles.outputs.CS_FILES }}
        run: |
          $csArray = $env:CS_LIST | ConvertFrom-Json

          # Helper: simple topological sort based on #region DEPENDS_ON comments
          function Get-Dependencies($path) {
            $deps = @()
            if (Test-Path $path) {
              $content = Get-Content $path -Raw
              if ($content -match '(?s)//\s*DEPENDS_ON\s*:\s*(.+?)$') {
                $raw = $Matches[1] -split ',' | ForEach-Object { $_.Trim() }
                foreach ($d in $raw) { if ($d) { $deps += $d } }
              }
            }
            return $deps
          }

          # Build a map: file → list of files it depends on
          $graph = @{}
          foreach ($f in $csArray) { $graph[$f] = Get-Dependencies $f }

          # Very small Kahn's algorithm (handles only explicit DEPENDS_ON)
          $ordered = @()
          $inDegree = @{}
          foreach ($f in $csArray) { $inDegree[$f] = 0 }
          foreach ($f in $csArray) {
            foreach ($dep in $graph[$f]) {
              if ($csArray -contains $dep) { $inDegree[$dep]++ }
            }
          }

          $queue = $csArray | Where-Object { $inDegree[$_] -eq 0 }
          while ($queue) {
            $node = $queue[0]
            $queue = $queue[1..$queue.Length]
            $ordered += $node
            foreach ($neighbor in $graph.Keys | Where-Object { $graph[$_] -contains $node }) {
              $inDegree[$neighbor]--
              if ($inDegree[$neighbor] -eq 0) { $queue += $neighbor }
            }
          }

          if ($ordered.Count -lt $csArray.Count) {
            Write-Warning "Circular or missing dependencies detected. Falling back to alphabetical order."
            $ordered = $csArray | Sort-Object
          }

          # -------------------------------------------------
          # Compile in the computed order
          # -------------------------------------------------
          $referenceList = @()
          foreach ($file in $ordered) {
            $projName = [IO.Path]::GetFileNameWithoutExtension($file)
            $projDir  = "temp_proj/$projName"
            New-Item -ItemType Directory -Force -Path $projDir | Out-Null

            # ---- create a minimal .csproj for this file ----
            $csproj = @"
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net48</TargetFramework>   <!-- .NET Framework 4.8 matches most WebForms -->
    <OutputType>Library</OutputType>
    <RootNamespace>$projName</RootNamespace>
    <AssemblyName>$projName</AssemblyName>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="`"$($file.Replace('\','\\'))`"" />
  </ItemGroup>

  <ItemGroup>
    <!-- Reference every DLL we already built -->
    $(
      $referenceList | ForEach-Object { "<Reference Include=`"$([IO.Path]::GetFileNameWithoutExtension($_))`"><HintPath>../artifacts/$([IO.Path]::GetFileName($_))</HintPath></Reference>" }
    )
  </ItemGroup>
</Project>
"@
            Set-Content -Path "$projDir/$projName.csproj" -Value $csproj

            # ---- compile ----
            dotnet build "$projDir/$projName.csproj" -c Release -o artifacts
            if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

            # keep the DLL path for next references
            $dll = "artifacts/$projName.dll"
            if (Test-Path $dll) { $referenceList += $dll }
          }

          Write-Host "All DLLs built → artifacts/"

      # -------------------------------------------------
      # 6. Upload DLLs as artifact
      # -------------------------------------------------
      - name: Upload DLL artifacts
        uses: actions/upload-artifact@v4
        with:
          name: compiled-dlls
          path: artifacts/*.dll
          if-no-files-found: error
